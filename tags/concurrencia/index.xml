<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>concurrencia on Blog | Friends of GO</title>
    <link>https://blog.friendsofgo.tech/tags/concurrencia/</link>
    <description>Recent content in concurrencia on Blog | Friends of GO</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>es-ES</language>
    <lastBuildDate>Mon, 19 Aug 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://blog.friendsofgo.tech/tags/concurrencia/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Patrones de concurrencia: work</title>
      <link>https://blog.friendsofgo.tech/posts/patrones-de-concurrencia-work/</link>
      <pubDate>Mon, 19 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>https://blog.friendsofgo.tech/posts/patrones-de-concurrencia-work/</guid>
      <description>El calor (o el frío, según el hemisferio en el que viváis) sigue, y con ello los patrones de concurrencia. Ya hemos publicado unos cuantos artículos sobre algunos de ellos, pero aún nos quedan más por publicar. Y a ello vamos. Esta vez es el turno del patrón de concurrencia work.
Contextualización de la problemática Si hacéis un poco de memoria, y si no podéis echarle un vistazo al último artículo, recordaréis que el patrón pooling hace uso de un buffered channel como método para almacenar varios recursos compartidos.</description>
    </item>
    
    <item>
      <title>Patrones de concurrencia: pooling</title>
      <link>https://blog.friendsofgo.tech/posts/patrones-de-concurrencia-pooling/</link>
      <pubDate>Mon, 12 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>https://blog.friendsofgo.tech/posts/patrones-de-concurrencia-pooling/</guid>
      <description>Hace tres semanas, y después de meses recibiendo feedback reclamando más artículos sobre la concurrencia en Go, decidimos empezar una nueva serie de artículos sobre patrones de concurrencia que ha dado mucho de que hablar.
Dicha serie empezó con uno de los patrones más comunes entre las aplicaciones concurrentes en Go: el patrón context. Después seguimos repasando otro patrón, también muy habitual a la hora de manejar grades volúmenes de datos de diferentes fuentes: el patrón pipeline.</description>
    </item>
    
    <item>
      <title>Data races vs Race conditions</title>
      <link>https://blog.friendsofgo.tech/posts/data-races-vs-race-conditions/</link>
      <pubDate>Mon, 05 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>https://blog.friendsofgo.tech/posts/data-races-vs-race-conditions/</guid>
      <description>Hoy os traemos un artículo algo diferente, y es que esta vez se trata de una traducción de otro artículo. El artículo al cual haremos referencia es: https://cronokirby.github.io/posts/data-races-vs-race-conditions, y hemos tomado esta opción porque el artículo original está genial como está, pero queremos que sea accesible nuestra comunidad hispana por lo interesante que es.
En este post se hablará sobre la diferencia entre Data Races y Race Conditions, y como las estructuras de datos o patrones de datos que a priori están libres Data Races pueden acabar en Race conditions.</description>
    </item>
    
    <item>
      <title>Patrones de concurrencia: pipeline</title>
      <link>https://blog.friendsofgo.tech/posts/patrones-de-concurrencia-pipeline/</link>
      <pubDate>Mon, 29 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://blog.friendsofgo.tech/posts/patrones-de-concurrencia-pipeline/</guid>
      <description>Lo dijimos, y lo prometido es deuda. Volvemos a la carga para seguir nuestra serie de patrones de concurrencia con un nuevo patrón. De nuevo, intentando dar solución a problematicas para las que aún no habíamos dado respuesta. Hoy es el turno de las pipelines.
De hecho, una pipeline no es ninguna definición formal en el contexto de la terminología de Go. Pero, sí que podemos definir dicho concepto de manera informal:</description>
    </item>
    
    <item>
      <title>Patrones de concurrencia: context</title>
      <link>https://blog.friendsofgo.tech/posts/patrones-de-concurrencia-context/</link>
      <pubDate>Mon, 15 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://blog.friendsofgo.tech/posts/patrones-de-concurrencia-context/</guid>
      <description>Una de las principales características por las que, los nuevos allegados al lenguaje de programación Go, suelen mostrar un mayor interés es por la gestión de la concurrencia en el mismo. Sin embargo, es importante recordar que Go no es un lenguaje que destaque estrictamente por esa característica, pues al final estamos hablando de un lenguaje de programación compilado, tipado y con una sencillez comparable a la de Python. Siendo éste último el lenguaje considerado de excelencia (por su sencillez) para los que se inician en la programación.</description>
    </item>
    
    <item>
      <title>Concurrencia en Golang: WaitGroups</title>
      <link>https://blog.friendsofgo.tech/posts/concurrencia-en-golang-waitgroups/</link>
      <pubDate>Mon, 08 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://blog.friendsofgo.tech/posts/concurrencia-en-golang-waitgroups/</guid>
      <description>En la primera parte sobre concurrencia hablamos sobre cómo empezar a realizar concurrencia, y de algunas de las particularidades nativas que nos traía Go, como es la palabra go para lanzar las gorrutinas, y dentro del mundo de los canales, los unbuffered channels y como gestionarlos con select y bucles infinitos dentro de otras gorrutinas.
Por si todo esto fuera poco, nuestro compañero Joan, nos hablaba del modelo de actores, algo muy común en lenguajes como Elixir o Erlang, y cómo realizarlo en Go.</description>
    </item>
    
    <item>
      <title>Repasando el modelo de actores en Go</title>
      <link>https://blog.friendsofgo.tech/posts/repasando-el-modelo-de-actores-en-go/</link>
      <pubDate>Tue, 25 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://blog.friendsofgo.tech/posts/repasando-el-modelo-de-actores-en-go/</guid>
      <description>La mayoría de nosotros, cuándo oímos hablar del modelo de actores (o actor model en inglés), o bien no sabemos de qué estamos hablando, o bien nos viene a la cabeza el framework Akka (para la JVM, entre cuyas funcionalidades destaca el soporte para el modelo de actores).
Para los primeros, el modelo de actores es un modelo de concurrencia sobre el que centraremos el artículo de hoy. Para los segundos, hoy veremos una posible implementación del mismo en el ecosistema Go.</description>
    </item>
    
    <item>
      <title>Concurrencia en Golang</title>
      <link>https://blog.friendsofgo.tech/posts/concurrencia-en-golang/</link>
      <pubDate>Mon, 17 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://blog.friendsofgo.tech/posts/concurrencia-en-golang/</guid>
      <description>No es ningún misterio que una de las principales características por las que la gente se interesa por Go es la concurrencia. La premisa de Go con la concurrencia es hacerla sencilla y manejable para todos, cosa que no podemos decir de otros lenguajes, donde incluso ni existe la concurrencia y tenemos que buscarnos la vida de otras maneras.
Pero antes de meternos de llenos a picar, deberíamos entender bien que es la concurrencia y en qué se diferencia del paralelismo, ya que muchas veces estos términos tienden a confundirse.</description>
    </item>
    
  </channel>
</rss>