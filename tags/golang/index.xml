<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>golang on Blog | Friends of GO</title>
    <link>https://blog.friendsofgo.tech/tags/golang/</link>
    <description>Recent content in golang on Blog | Friends of GO</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>es-ES</language>
    <lastBuildDate>Mon, 15 Jul 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://blog.friendsofgo.tech/tags/golang/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Patrones de concurrencia: context</title>
      <link>https://blog.friendsofgo.tech/posts/patrones-de-concurrencia-context/</link>
      <pubDate>Mon, 15 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://blog.friendsofgo.tech/posts/patrones-de-concurrencia-context/</guid>
      <description>Una de las principales características por las que, los nuevos allegados al lenguaje de programación Go, suelen mostrar un mayor interés es por la gestión de la concurrencia en el mismo. Sin embargo, es importante recordar que Go no es un lenguaje que destaque estrictamente por esa característica, pues al final estamos hablando de un lenguaje de programación compilado, tipado y con una sencillez comparable a la de Python. Siendo éste último el lenguaje considerado de excelencia (por su sencillez) para los que se inician en la programación.</description>
    </item>
    
    <item>
      <title>Concurrencia en Golang: WaitGroups</title>
      <link>https://blog.friendsofgo.tech/posts/concurrencia-en-golang-waitgroups/</link>
      <pubDate>Mon, 08 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://blog.friendsofgo.tech/posts/concurrencia-en-golang-waitgroups/</guid>
      <description>En la primera parte sobre concurrencia hablamos sobre cómo empezar a realizar concurrencia, y de algunas de las particularidades nativas que nos traía Go, como es la palabra go para lanzar las gorrutinas, y dentro del mundo de los canales, los unbuffered channels y como gestionarlos con select y bucles infinitos dentro de otras gorrutinas.
Por si todo esto fuera poco, nuestro compañero Joan, nos hablaba del modelo de actores, algo muy común en lenguajes como Elixir o Erlang, y cómo realizarlo en Go.</description>
    </item>
    
    <item>
      <title>Crear un bot de Slack en Go</title>
      <link>https://blog.friendsofgo.tech/posts/crear-un-bot-de-slack-en-go/</link>
      <pubDate>Mon, 01 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://blog.friendsofgo.tech/posts/crear-un-bot-de-slack-en-go/</guid>
      <description>Slack es una herramienta de comunicación en equipo que se lanzó al mercado en agosto del 2013. Ofrece salas de chat organizadas por temas, así como grupos privados y mensajes directos. Posee un cuadro de búsqueda que permite acceder a todo el contenido de la aplicación y, además, integra una gran cantidad de servicios a terceros y respalda las integraciones hechas por la comunidad.
Como decíamos, las integraciones de la comunidad de servicios a terceros son una de las funcionalidades más exitosas de Slack, sin embargo, si tuviéramos que destacar dos de ellas, nos quedaríamos con los bots y los slash commands.</description>
    </item>
    
    <item>
      <title>Repasando el modelo de actores en Go</title>
      <link>https://blog.friendsofgo.tech/posts/repasando-el-modelo-de-actores-en-go/</link>
      <pubDate>Tue, 25 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://blog.friendsofgo.tech/posts/repasando-el-modelo-de-actores-en-go/</guid>
      <description>La mayoría de nosotros, cuándo oímos hablar del modelo de actores (o actor model en inglés), o bien no sabemos de qué estamos hablando, o bien nos viene a la cabeza el framework Akka (para la JVM, entre cuyas funcionalidades destaca el soporte para el modelo de actores).
Para los primeros, el modelo de actores es un modelo de concurrencia sobre el que centraremos el artículo de hoy. Para los segundos, hoy veremos una posible implementación del mismo en el ecosistema Go.</description>
    </item>
    
    <item>
      <title>Concurrencia en Golang</title>
      <link>https://blog.friendsofgo.tech/posts/concurrencia-en-golang/</link>
      <pubDate>Mon, 17 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://blog.friendsofgo.tech/posts/concurrencia-en-golang/</guid>
      <description>No es ningún misterio que una de las principales características por las que la gente se interesa por Go es la concurrencia. La premisa de Go con la concurrencia es hacerla sencilla y manejable para todos, cosa que no podemos decir de otros lenguajes, donde incluso ni existe la concurrencia y tenemos que buscarnos la vida de otras maneras.
Pero antes de meternos de llenos a picar, deberíamos entender bien que es la concurrencia y en qué se diferencia del paralelismo, ya que muchas veces estos términos tienden a confundirse.</description>
    </item>
    
    <item>
      <title>Try: la propuesta para mejorar la gestión de errores</title>
      <link>https://blog.friendsofgo.tech/posts/try-la-propuesta-para-mejorar-la-gestion-de-errores/</link>
      <pubDate>Mon, 10 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://blog.friendsofgo.tech/posts/try-la-propuesta-para-mejorar-la-gestion-de-errores/</guid>
      <description>La gestión de errores en Go es un tema que está en boca de todos: gophers o no, favorables al lenguaje o no. Y es precisamente esa la razón por la que David López Carrascal nos deleitó con una gran introducción al tema.
Sin embargo, parece que la decisión de prescindir de las excepciones (como tal, panics a parte) es algo que sigue contrariando a una parte considerable de la comunidad.</description>
    </item>
    
    <item>
      <title>Gestión de dependencias en Golang</title>
      <link>https://blog.friendsofgo.tech/posts/gestion-de-dependencias-en-golang/</link>
      <pubDate>Mon, 03 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://blog.friendsofgo.tech/posts/gestion-de-dependencias-en-golang/</guid>
      <description>Supongo que no os coge de nuevo el tema de gestión de dependencias, pues lo llevamos realizando desde mucho tiempo en distintos lenguajes de programación. Véase Java o Php, entre otros. y además todos estos lenguajes nos ofrecían herramientas para poder gestionar dichas dependencias de una manera sencilla y desacoplada de nuestra aplicación en sí.
En Go supongo que os resultará realmente familiar encontrarnos con un main similar al de GopherApi:</description>
    </item>
    
    <item>
      <title>La expansión de Friends of Go</title>
      <link>https://blog.friendsofgo.tech/posts/la_expansion_de_friends_of_go/</link>
      <pubDate>Mon, 27 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://blog.friendsofgo.tech/posts/la_expansion_de_friends_of_go/</guid>
      <description>En Friends of Go nos gustan las emociones fuertes y, con tal de tenerlas, no nos importa desarrollar nuestro propio Mock Server con nombre de villano de Marvel, grabar un curso con los maravillosos chicos de CodelyTV o hacer cuatro horas de avión para ir a Moscú a dar una charla.
Y es gracias a esa actitud, que las tareas en nuestro backlog de &amp;ldquo;expansión&amp;rdquo; se deshacen como un azucarillo en una taza de café.</description>
    </item>
    
    <item>
      <title>Gestión de Errores en Golang</title>
      <link>https://blog.friendsofgo.tech/posts/gestion-de-errores-en-golang/</link>
      <pubDate>Mon, 20 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://blog.friendsofgo.tech/posts/gestion-de-errores-en-golang/</guid>
      <description>La gestión de errores es una de las cosas con las que los programadores nos encontramos todos los días y hay que darle la importancia que merece. En este articulo hablaremos de las diferentes formas que tenemos de crear un error en Go, como capturarlo y personalizarlo. Todo esto con un toque de Juego de Tronos, para que no sea tan aburrido.
Go, un lenguaje sin excepciones Actualmente, la mayoría de los lenguages de programación lo hacen con excepciones, pero este no es el caso de Go.</description>
    </item>
    
    <item>
      <title>¿Cómo usar reflection en Golang?</title>
      <link>https://blog.friendsofgo.tech/posts/como-usar-reflection-en-golang/</link>
      <pubDate>Mon, 13 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://blog.friendsofgo.tech/posts/como-usar-reflection-en-golang/</guid>
      <description>¿Qué es reflection? Reflection es la habilidad que tiene un programa para examinar y modificar su propia estructura y comportamiento en tiempo de ejecución. El propósito que tiene reflection es la de permitir a los programadores crear código genérico, además es la clave para poder realizar metaprogramación
Cada lenguaje tiene su propia forma de realizar reflection y Go no iba a ser menos, pero cada forma de aplicarlo es distinta ya que ésta se utiliza sobre el sistema de tipos del propio lenguaje.</description>
    </item>
    
    <item>
      <title>Orientación a Objetos: Polimorfismo</title>
      <link>https://blog.friendsofgo.tech/posts/orientacion-a-objetos-polimorfismo/</link>
      <pubDate>Mon, 06 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://blog.friendsofgo.tech/posts/orientacion-a-objetos-polimorfismo/</guid>
      <description>Llegamos a nuestro último artículo sobre Go enfocado a programación orientada a objetos, en este artículo tocaremos un aspecto muy importante de la OO, nada más y nada menos que el polimorfismo y como utilizarlo en GO
¿Qué es el polimorfismo? Cómo casi todos los términos que hay en programación parece algo más complicado de lo que es, pero una vez te lo explique verás que te queda muy claro e incluso puede que ya lo estuvieras aplicando sin ni siquiera conocer como se llamaba, esto suele pasar mucho en nuestro trabajo.</description>
    </item>
    
    <item>
      <title>Los nil serán nil</title>
      <link>https://blog.friendsofgo.tech/posts/los_nil_seran_nil/</link>
      <pubDate>Mon, 29 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>https://blog.friendsofgo.tech/posts/los_nil_seran_nil/</guid>
      <description>En marzo de 2012, la cantante mexicana Paulina Rubio publicó un nuevo single llamado &amp;ldquo;Boys Will Be Boys&amp;rdquo;, título que podríamos traducir a &amp;ldquo;Los chicos serán chicos&amp;rdquo;. En ella, Paulina habla de una historia de amor a la vez que cuenta algunas de las particularidades de los chicos, desde su punto de vista. Hoy, con &amp;ldquo;Los nil serán nil&amp;rdquo;, os queremos contar nuestra historia de amor con Go y, más concretamente, las particularidades de los nil.</description>
    </item>
    
    <item>
      <title>Orientación a Objetos: Composición</title>
      <link>https://blog.friendsofgo.tech/posts/orientacion-a-objectos-composicion/</link>
      <pubDate>Mon, 22 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>https://blog.friendsofgo.tech/posts/orientacion-a-objectos-composicion/</guid>
      <description>El gran dilema de la programación orientada a objetos ¿herencia o composición?, es un debate que suele ocurrir constantemente, pero que Go, para bien o para mal (creo que para bien) ha decidido que no ocurra en su lenguaje, y es que en Go la herencia no existe, sólo la composición.
La composición significa utilizar objetos dentro de otros objetos. Y en Go no puede hacerse más sencillo.
Composición por structs incrustados(embedding structs) Una de las formas de composición que ofrece Go es a través de incrustar un typed struct dentro de otro.</description>
    </item>
    
    <item>
      <title>Orientación a Objetos: Structs</title>
      <link>https://blog.friendsofgo.tech/posts/orientacion_a_objetos_structs/</link>
      <pubDate>Mon, 15 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>https://blog.friendsofgo.tech/posts/orientacion_a_objetos_structs/</guid>
      <description>En un artículo previo nos preguntamos si Go podía ser un lenguaje orientado a objetos, y llegamos a la conclusión de que sí, pero que debía ser utilizado de la manera correcta y no llevando el modo en que aplicamos la OO en los otros lenguajes.
En este artículo queremos explicar como funcionan los structs y como utilizarlos de la manera correcta, para muchos puede parece algo básico, pero no está demás repasar un poco.</description>
    </item>
    
    <item>
      <title>¿Cómo estructurar tus proyectos en Go?</title>
      <link>https://blog.friendsofgo.tech/posts/como_estructurar_tus_aplicaciones_go/</link>
      <pubDate>Mon, 08 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>https://blog.friendsofgo.tech/posts/como_estructurar_tus_aplicaciones_go/</guid>
      <description>¿Cuántas veces has empezado un nuevo proyecto en Go y te han surgido dudas sobre cómo organizar tú código? Por suerte, o por desgracia, la mayoría de los que estamos metidos en esto venimos de entornos como Java, PHP o C#, dónde el uso de namespaces está extendido como una práctica habitual. Sin embargo, cuándo uno empieza a programar en Go y descubre cómo funciona su sistema de paquetes, tiende a quedarse bloqueado.</description>
    </item>
    
    <item>
      <title>¿Es Go un lenguaje orientado a objetos?</title>
      <link>https://blog.friendsofgo.tech/posts/es_go_un_lenguaje_orientado_a_objetos/</link>
      <pubDate>Mon, 01 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>https://blog.friendsofgo.tech/posts/es_go_un_lenguaje_orientado_a_objetos/</guid>
      <description>Seguro que algún momento de tu vida como desarrollador Go o si estás empezando y vienes de otro lenguaje, te habrás hecho esta fabulosa pregunta. Y es que cuando uno empieza en Go todo parece muy distinto a lo que estamos acostumbrados, pero también hay cosas que nos resultan muy familiares.
Si estás empezando con Go y me haces está pregunta, probablemente te diría que No, que no es un lenguaje orientado a objetos, ¿pero es esto realmente cierto?</description>
    </item>
    
    <item>
      <title>Integración continua en Golang</title>
      <link>https://blog.friendsofgo.tech/posts/integracion_continua_en_golang/</link>
      <pubDate>Mon, 11 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://blog.friendsofgo.tech/posts/integracion_continua_en_golang/</guid>
      <description>En pasados artículos hemos estado interactuando con nuestra API, GopherApi, ya hemos desarrollado diferentes endpoints y además hemos incluido los test del mismo.
Nuestra API además es de software libre y cualquier persona puede realizar PRs (Pull Request) sobre ella, con lo cuál necesitamos un sistema que nos verifique que los PRs cumplen con unos estándares puestos por nosotros para asegurarnos que al integrarlos en la rama master no se produzca ningún error.</description>
    </item>
    
    <item>
      <title>¿Cómo testear nuestra API en Golang?</title>
      <link>https://blog.friendsofgo.tech/posts/como_testear_nuestra_api_en_go/</link>
      <pubDate>Mon, 04 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://blog.friendsofgo.tech/posts/como_testear_nuestra_api_en_go/</guid>
      <description>En un pasado artículo os explicábamos como crear una API Rest en Go, pero no llegamos a explicar como poder testear dicha API y, como sabemos, testear nuestra aplicación es muy muy importante si queremos poder hacer refactors sin miedo, u obviamente evitar bugs.
¿Pero y cómo testeo los handlers? Pues primeramente deberas estar familiarizado con la forma de testing en GO, cosa que ya os explicábamos en el artículo Empezando con los test automatizados en Go, recordad que se le llama test automatizado a todo test que ha sido automatizado y no tenemos que realizar a mano, luego dentro encontramos distintos tipos como son los Unitarios o Units que son los que veremos ahora.</description>
    </item>
    
    <item>
      <title>Analizando el rendimiento de tus aplicaciones Go: El determinismo de las pruebas</title>
      <link>https://blog.friendsofgo.tech/posts/analizando-el-rendimiento-de-tus-aplicaciones-go-determinismo/</link>
      <pubDate>Mon, 25 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>https://blog.friendsofgo.tech/posts/analizando-el-rendimiento-de-tus-aplicaciones-go-determinismo/</guid>
      <description>Entendemos por algoritmo determinista como aquél algoritmo qué, en términos informales, es completamente predictivo si se conocen sus entradas. Cuándo hablamos de pruebas (tests), entendemos que éstas son deterministas sí, dada una implementación concreta, el resultado de la prueba (OK o KO) es siempre el mismo. Lo mismo lo podemos extrapolar a pruebas de carga o estrés.
 Seguimos con el jefe del proyecto preguntando por las mejoras de nuestra implementación, pues, a pesar de que vimos como comparar el rendimiento de nuestras implementaciones, aún no hemos sido capaces de encontrar qué es lo que hace qué nuestra implementación sea excesivamente lenta en comparación con la de la competencia.</description>
    </item>
    
    <item>
      <title>¿Cómo crear una API Rest en Golang?</title>
      <link>https://blog.friendsofgo.tech/posts/como_crear_una_api_rest_en_golang/</link>
      <pubDate>Mon, 18 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>https://blog.friendsofgo.tech/posts/como_crear_una_api_rest_en_golang/</guid>
      <description>Ya os hemos explicado como crear un command line en Go utilizando los paquetes que nos ofrece Go en el propio lenguaje, sin necesidad de ninguna librería externa.
Pues esta vez crearemos nuestra primera API Rest, exclusivamente con lo que Go nos permite de entrada, bueno veremos que esto no es exactamente cierto, haremos algo de trampa y utilizaremos alguna librería externa, pero ningún framework.
¿Por qué no usamos un framework?</description>
    </item>
    
    <item>
      <title>Analizando el rendimiento de tus aplicaciones Go: Benchmarking</title>
      <link>https://blog.friendsofgo.tech/posts/analizando-el-rendimiento-de-tus-aplicaciones-go-benchmarking/</link>
      <pubDate>Mon, 11 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>https://blog.friendsofgo.tech/posts/analizando-el-rendimiento-de-tus-aplicaciones-go-benchmarking/</guid>
      <description>Entendemos por benchmarking como el proceso por el cual se obtiene información útil que ayuda a una organización a mejorar sus procesos, con el objetivo de conseguir la máxima eficacia, ayudando a la empresa a moverse desde donde está hacia dónde quiere llegar.
 Hoy vamos a suponer que, cada uno de vosotros, ha dejado su actual empleo, y se ha unido a un nuevo proyecto: un integrador de servicios de intercambio de criptomonedas.</description>
    </item>
    
    <item>
      <title>Semantic Versioning</title>
      <link>https://blog.friendsofgo.tech/posts/semantic-versioning/</link>
      <pubDate>Mon, 04 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>https://blog.friendsofgo.tech/posts/semantic-versioning/</guid>
      <description>El tema que vamos a tratar hoy no sólo afecta a GO sino que es un tema que se trata en general en el mundo del software. Y va íntimamente ligado al tema de dependencias que llevamos tratando durante el pasado mes de Enero.
¿Por qué existe el Semantic Versioning? Cuando Go Modules hace su magia y nos baja las dependencias que tiene nuestro proyecto, modifica y añade las líneas necesarias de dichas dependencias al fichero go.</description>
    </item>
    
    <item>
      <title>Crear tu primer CLI en GO</title>
      <link>https://blog.friendsofgo.tech/posts/crear-tu-primer-cli-en-go/</link>
      <pubDate>Mon, 28 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>https://blog.friendsofgo.tech/posts/crear-tu-primer-cli-en-go/</guid>
      <description>Construyendo una herramienta de cliente en GO Seguro que en tu día a día te has encontrado con que utilizas multitud de herramientas de línea de comandos como desarrollador, véase Git o Docker, entre otras. Incluso puede que hayas creado las tuyas propias en algún momento de tu vida.
Pero, ¿cómo se hacen en GO? Por suerte para nosotros, y para variar, GO viene con la solución bajo el brazo, sin tener que recurrir a librerías externas.</description>
    </item>
    
    <item>
      <title>Empezando con los tests automatizados en Go</title>
      <link>https://blog.friendsofgo.tech/posts/empezando-con-los-tests-automatizados-en-go/</link>
      <pubDate>Mon, 21 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>https://blog.friendsofgo.tech/posts/empezando-con-los-tests-automatizados-en-go/</guid>
      <description>Empezar a escribir tests automatizados en Go es tan fácil que no requiere de librerías externas, como sí ocurre en otros lenguajes (véase PHPUnit o JUnit). En esta ocasión, el core de Go nos proporciona, tanto los paquetes necesarios (testing) como el binario para la ejecución de los mismos (go test).
Veamos un sencillo ejemplo:
package main import ( &amp;#34;strings&amp;#34; &amp;#34;testing&amp;#34; ) func IsSuperAnimal(animal string) bool { return strings.ToLower(animal) == &amp;#34;gopher&amp;#34; } func TestIsSuperAnimal(t *testing.</description>
    </item>
    
    <item>
      <title>Migrar a Go Modules fácilmente</title>
      <link>https://blog.friendsofgo.tech/posts/migrar-a-go-modules-facilmente/</link>
      <pubDate>Mon, 14 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>https://blog.friendsofgo.tech/posts/migrar-a-go-modules-facilmente/</guid>
      <description>En un artículo anterior vimos lo sencillo que era empezar a usar Go Modules, pero, ¿y si os digo que es igual de fácil migrar un proyecto a Go Modules desde los anteriores gestores de dependencias? Sí seguro que pensaréis que estoy de coña, así que vamos a verlo.
Buscar un repositorio con Glide o Dep Esto no debería ser muy complicado, de hecho, seguro que a día de hoy muchos de los repositorios de proyectos GO en GitHub utilizan uno de estos gestores de dependencias.</description>
    </item>
    
    <item>
      <title>Dockerizando tu aplicación en Go</title>
      <link>https://blog.friendsofgo.tech/posts/dockerizando-tu-aplicacion-en-go/</link>
      <pubDate>Mon, 07 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>https://blog.friendsofgo.tech/posts/dockerizando-tu-aplicacion-en-go/</guid>
      <description>Si estás interesado por los contenedores (concretamente por Docker) y estás inmerso en el mundo de Go, entonces es probable que te hayas preguntado cómo puedes dockerizar tu aplicación. Y aquí estamos para explicártelo, a la vez que repasamos algunos conceptos básicos y buenas prácticas de Go.
Por suerte, el proceso de dockerizar una aplicación escrita en Go es muy sencillo, pues, conceptualmente, lo único que tenemos que hacer es compilar nuestra aplicación para generar el binario que irá dentro del contenedor.</description>
    </item>
    
    <item>
      <title>Go Modules en 3 pasos</title>
      <link>https://blog.friendsofgo.tech/posts/go-modules-en-tres-pasos/</link>
      <pubDate>Tue, 01 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>https://blog.friendsofgo.tech/posts/go-modules-en-tres-pasos/</guid>
      <description>Si ya has estado experimentando un poco con el lenguaje de programación GO habrás descubierto que cada vez que quieres usar un nuevo paquete, éste se te descarga en el GOPATH de forma que usar versiones determinadas en cada proyecto se vuelve imposible.
Por suerte para nosotros tenemos varias alternativas a la gestión de dependencias en GO pero desde la versión 1.11 del mismo lo tenemos de forma nativa.</description>
    </item>
    
    <item>
      <title>Bienvenidos a Friends of Go</title>
      <link>https://blog.friendsofgo.tech/posts/bienvienidos-a-friends-of-go/</link>
      <pubDate>Fri, 21 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://blog.friendsofgo.tech/posts/bienvienidos-a-friends-of-go/</guid>
      <description>Con esta entrada queremos innagurar nuestro nuevo blog.
¿De qué irá este blog? Como bien sabéis (y sino lo sabéis os lo decimos ahora), Friends of GO nace con la idea de acercar GO a los desarrolladores.
Go es un lenguaje de programación relativamente nuevo, vio la luz en 2009 y desde ahí no ha parado de crecer y de ser adoptado por más y más proyectos en el mundo entero.</description>
    </item>
    
  </channel>
</rss>