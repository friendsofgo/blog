<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>modelo de concurrencia on Blog | Friends of GO</title>
    <link>https://blog.friendsofgo.tech/tags/modelo-de-concurrencia/</link>
    <description>Recent content in modelo de concurrencia on Blog | Friends of GO</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>es-ES</language>
    <lastBuildDate>Mon, 12 Aug 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://blog.friendsofgo.tech/tags/modelo-de-concurrencia/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Patrones de concurrencia: pooling</title>
      <link>https://blog.friendsofgo.tech/posts/patrones-de-concurrencia-pooling/</link>
      <pubDate>Mon, 12 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>https://blog.friendsofgo.tech/posts/patrones-de-concurrencia-pooling/</guid>
      <description>Hace tres semanas, y después de meses recibiendo feedback reclamando más artículos sobre la concurrencia en Go, decidimos empezar una nueva serie de artículos sobre patrones de concurrencia que ha dado mucho de que hablar.
Dicha serie empezó con uno de los patrones más comunes entre las aplicaciones concurrentes en Go: el patrón context. Después seguimos repasando otro patrón, también muy habitual a la hora de manejar grades volúmenes de datos de diferentes fuentes: el patrón pipeline.</description>
    </item>
    
    <item>
      <title>Patrones de concurrencia: pipeline</title>
      <link>https://blog.friendsofgo.tech/posts/patrones-de-concurrencia-pipeline/</link>
      <pubDate>Mon, 29 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://blog.friendsofgo.tech/posts/patrones-de-concurrencia-pipeline/</guid>
      <description>Lo dijimos, y lo prometido es deuda. Volvemos a la carga para seguir nuestra serie de patrones de concurrencia con un nuevo patrón. De nuevo, intentando dar solución a problematicas para las que aún no habíamos dado respuesta. Hoy es el turno de las pipelines.
De hecho, una pipeline no es ninguna definición formal en el contexto de la terminología de Go. Pero, sí que podemos definir dicho concepto de manera informal:</description>
    </item>
    
    <item>
      <title>Patrones de concurrencia: context</title>
      <link>https://blog.friendsofgo.tech/posts/patrones-de-concurrencia-context/</link>
      <pubDate>Mon, 15 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://blog.friendsofgo.tech/posts/patrones-de-concurrencia-context/</guid>
      <description>Una de las principales características por las que, los nuevos allegados al lenguaje de programación Go, suelen mostrar un mayor interés es por la gestión de la concurrencia en el mismo. Sin embargo, es importante recordar que Go no es un lenguaje que destaque estrictamente por esa característica, pues al final estamos hablando de un lenguaje de programación compilado, tipado y con una sencillez comparable a la de Python. Siendo éste último el lenguaje considerado de excelencia (por su sencillez) para los que se inician en la programación.</description>
    </item>
    
    <item>
      <title>Repasando el modelo de actores en Go</title>
      <link>https://blog.friendsofgo.tech/posts/repasando-el-modelo-de-actores-en-go/</link>
      <pubDate>Tue, 25 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://blog.friendsofgo.tech/posts/repasando-el-modelo-de-actores-en-go/</guid>
      <description>La mayoría de nosotros, cuándo oímos hablar del modelo de actores (o actor model en inglés), o bien no sabemos de qué estamos hablando, o bien nos viene a la cabeza el framework Akka (para la JVM, entre cuyas funcionalidades destaca el soporte para el modelo de actores).
Para los primeros, el modelo de actores es un modelo de concurrencia sobre el que centraremos el artículo de hoy. Para los segundos, hoy veremos una posible implementación del mismo en el ecosistema Go.</description>
    </item>
    
  </channel>
</rss>